.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "RPi::WiringPi::Core 3"
.TH RPi::WiringPi::Core 3 "2016-08-15" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
RPi::WiringPi::Core \- Tight Perl wrapper for Rasperry Pi's wiringPi C library
functionality
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1WARNING:\s0 Until version 1.00 has been released, the \s-1API\s0 along with functionality
may change at any time without any notice. If you happen to be testing with 
this software and find something broken, please contact me.
.PP
This is an XS-based module, and requires wiringPi <http://wiringpi.com> to be
installed. The \f(CW\*(C`wiringPiDev\*(C'\fR shared library is also required (for the \s-1LCD\s0
functionality), but it's installed by default with \f(CW\*(C`wiringPi\*(C'\fR.
.SH "CORE METHODS"
.IX Header "CORE METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Returns a new \f(CW\*(C`RPi::WiringPi::Core\*(C'\fR object.
.SS "\fIsetup()\fP"
.IX Subsection "setup()"
Maps to \f(CW\*(C`int wiringPiSetup()\*(C'\fR
.PP
See wiringPi setup functions <http://wiringpi.com/reference/setup> for
for information on this method.
.PP
Note that only one of the \f(CW\*(C`setup*()\*(C'\fR methods can be called per program run.
.SS "\fIsetup_sys()\fP"
.IX Subsection "setup_sys()"
Maps to \f(CW\*(C`int wiringPiSetupSys()\*(C'\fR
.PP
See wiringPi setup functions <http://wiringpi.com/reference/setup> for
for information on this method.
.PP
Note that only one of the \f(CW\*(C`setup*()\*(C'\fR methods can be called per program run.
.SS "\fIsetup_phys()\fP"
.IX Subsection "setup_phys()"
Maps to \f(CW\*(C`int wiringPiSetupPhys()\*(C'\fR
.PP
See wiringPi setup functions <http://wiringpi.com/reference/setup> for
for information on this method.
.PP
Note that only one of the \f(CW\*(C`setup*()\*(C'\fR methods can be called per program run.
.SS "\fIsetup_gpio()\fP"
.IX Subsection "setup_gpio()"
Maps to \f(CW\*(C`int wiringPiSetupGpio()\*(C'\fR
.PP
See wiringPi setup functions <http://wiringpi.com/reference/setup> for
for information on this method.
.PP
Note that only one of the \f(CW\*(C`setup*()\*(C'\fR methods can be called per program run.
.ie n .SS "pin_mode($pin, $mode)"
.el .SS "pin_mode($pin, \f(CW$mode\fP)"
.IX Subsection "pin_mode($pin, $mode)"
Maps to \f(CW\*(C`void pinMode(int pin, int mode)\*(C'\fR
.PP
Puts the \s-1GPIO\s0 pin in either \s-1INPUT\s0 or \s-1OUTPUT\s0 mode.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The \s-1GPIO\s0 pin number, using wiringPi's pin number representation.
.PP
.Vb 1
\&    $mode
.Ve
.PP
Mandatory: \f(CW0\fR for \s-1INPUT, \s0\f(CW1\fR \s-1OUTPUT, \s0\f(CW2\fR \s-1PWM_OUTPUT\s0 and \f(CW3\fR \s-1GPIO_CLOCK.\s0
.SS "read_pin($pin);"
.IX Subsection "read_pin($pin);"
Maps to \f(CW\*(C`int digitalRead(int pin)\*(C'\fR
.PP
Returns the current state (HIGH/on, LOW/off) of a given pin.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The wiringPi number representation of the \s-1GPIO\s0 pin.
.ie n .SS "write_pin($pin, $state)"
.el .SS "write_pin($pin, \f(CW$state\fP)"
.IX Subsection "write_pin($pin, $state)"
Maps to \f(CW\*(C`void digitalWrite(int pin)\*(C'\fR
.PP
Sets the state (HIGH/on, LOW/off) of a given pin.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The wiringPi number representation of the \s-1GPIO\s0 pin.
.PP
.Vb 1
\&    $state
.Ve
.PP
Mandatory: \f(CW1\fR to turn the pin on (\s-1HIGH\s0), and \f(CW0\fR to turn it \s-1LOW \s0(off).
.ie n .SS "pull_up_down($pin, $direction)"
.el .SS "pull_up_down($pin, \f(CW$direction\fP)"
.IX Subsection "pull_up_down($pin, $direction)"
Maps to \f(CW\*(C`void pullUpDnControl(int pin, int pud)\*(C'\fR
.PP
Enable/disable the built-in pull up/down resistors for a specified pin.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The wiringPi number representation of the \s-1GPIO\s0 pin.
.PP
.Vb 1
\&    $direction
.Ve
.PP
Mandatory: \f(CW2\fR for \s-1UP, \s0\f(CW1\fR for \s-1DOWN\s0 and \f(CW0\fR to disable the resistor.
.ie n .SS "pwm_write($pin, $value)"
.el .SS "pwm_write($pin, \f(CW$value\fP)"
.IX Subsection "pwm_write($pin, $value)"
Maps to \f(CW\*(C`void pwmWrite(int pin, int value)\*(C'\fR
.PP
Sets the Pulse Width Modulation duty cycle (on-time) of the pin.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The wiringPi number representation of the \s-1GPIO\s0 pin.
.PP
.Vb 1
\&    $value
.Ve
.PP
Mandatory: \f(CW0\fR to \f(CW1023\fR. \f(CW0\fR is 0% (off) and \f(CW1023\fR is 100% (fully on).
.SS "get_alt($pin)"
.IX Subsection "get_alt($pin)"
Maps to \f(CW\*(C`int getAlt(int pin)\*(C'\fR
.PP
This returns the current mode of the pin (using \f(CW\*(C`getAlt()\*(C'\fR C call). Modes are
\&\s-1INPUT \s0\f(CW0\fR, \s-1OUTPUT \s0\f(CW1\fR, \s-1PWM \s0\f(CW2\fR and \s-1CLOCK \s0\f(CW3\fR.
.PP
Parameters:
.PP
.Vb 1
\&    $pin
.Ve
.PP
Mandatory: The wiringPi number representation of the \s-1GPIO\s0 pin.
.SH "BOARD METHODS"
.IX Header "BOARD METHODS"
.SS "\fIboard_rev()\fP"
.IX Subsection "board_rev()"
Maps to \f(CW\*(C`int piBoardRev()\*(C'\fR
.PP
Returns the Raspberry Pi board's revision.
.SS "wpi_to_gpio($pin_num)"
.IX Subsection "wpi_to_gpio($pin_num)"
Maps to \f(CW\*(C`int wpiPinToGpio(int pin)\*(C'\fR
.PP
Converts a \f(CW\*(C`wiringPi\*(C'\fR pin number to the Broadcom (\s-1BCM\s0) representation, and
returns it.
.PP
Parameters:
.PP
.Vb 1
\&    $pin_num
.Ve
.PP
Mandatory: The \f(CW\*(C`wiringPi\*(C'\fR representation of a pin number.
.SS "phys_to_gpio($pin_num)"
.IX Subsection "phys_to_gpio($pin_num)"
Maps to \f(CW\*(C`int physPinToGpio(int pin)\*(C'\fR
.PP
Converts the pin number on the physical board to the Broadcom (\s-1BCM\s0)
representation, and returns it.
.PP
Parameters:
.PP
.Vb 1
\&    $pin_num
.Ve
.PP
Mandatory: The pin number on the physical Raspberry Pi board.
.SS "phys_to_wpi($pin_num)"
.IX Subsection "phys_to_wpi($pin_num)"
Maps to \f(CW\*(C`int physPinToWpi(int pin)\*(C'\fR
.PP
Converts the pin number on the physical board to the \f(CW\*(C`wiringPi\*(C'\fR numbering
representation, and returns it.
.PP
Parameters:
.PP
.Vb 1
\&    $pin_num
.Ve
.PP
Mandatory: The pin number on the physical Raspberry Pi board.
.SS "pwm_set_range($range);"
.IX Subsection "pwm_set_range($range);"
Maps to \f(CW\*(C`void pwmSetRange(int range)\*(C'\fR
.PP
Sets the range register of the Pulse Width Modulation (\s-1PWM\s0) functionality. It
defaults to \f(CW1024\fR (\f(CW\*(C`0\-1023\*(C'\fR).
.PP
Parameters:
.PP
.Vb 1
\&    $range
.Ve
.PP
Mandatory: An integer between \f(CW0\fR and \f(CW1023\fR.
.SH "LCD METHODS"
.IX Header "LCD METHODS"
There are several methods to drive standard Liquid Crystal Displays. See
wiringPiDev \s-1LCD\s0 page <http://wiringpi.com/dev-lib/lcd-library/> for full
details.
.SS "lcd_init(%args)"
.IX Subsection "lcd_init(%args)"
Maps to:
.PP
.Vb 4
\&    int lcdInit(
\&        rows, cols, bits, rs, strb,
\&        d0, d1, d2, d3, d4, d5, d6, d7
\&    );
.Ve
.PP
Initializes the \s-1LCD\s0 library, and returns an integer representing the handle
handle (file descriptor) of the device. The return is supposed to be constant,
so \s-1DON\s0'T change it.
.PP
Parameters:
.PP
.Vb 10
\&    %args = (
\&        rows => $num,       # number of rows. eg: 16 or 20
\&        cols => $num,       # number of columns. eg: 2 or 4
\&        bits => 4|8,        # width of the interface (4 or 8)
\&        rs => $pin_num,     # pin number of the LCD\*(Aqs RS pin
\&        strb => $pin_num,   # pin number of the LCD\*(Aqs strobe (E) pin
\&        d0 => $pin_num,     # pin number for LCD data pin 1
\&        ...
\&        d7 => $pin_num,     # pin number for LCD data pin 8
\&    );
.Ve
.PP
Mandatory: All entries must have a value. If you're only using four (4) bit
width, \f(CW\*(C`d4\*(C'\fR through \f(CW\*(C`d7\*(C'\fR must be set to \f(CW0\fR.
.PP
Note: When in 4\-bit mode, the \f(CW\*(C`d0\*(C'\fR through \f(CW3\fR parameters actually map to
pins \f(CW\*(C`d4\*(C'\fR through \f(CW\*(C`d7\*(C'\fR on the \s-1LCD\s0 board, so you need to connect those pins
to their respective selected \s-1GPIO\s0 pins.
.SS "lcd_home($fd)"
.IX Subsection "lcd_home($fd)"
Maps to \f(CW\*(C`void lcdHome(int fd)\*(C'\fR
.PP
Moves the \s-1LCD\s0 cursor to the home position (top row, leftmost column).
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.SS "lcd_clear($fd)"
.IX Subsection "lcd_clear($fd)"
Maps to \f(CW\*(C`void lcdClear(int fd)\*(C'\fR
.PP
Clears the \s-1LCD\s0 display.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.ie n .SS "lcd_display($fd, $state)"
.el .SS "lcd_display($fd, \f(CW$state\fP)"
.IX Subsection "lcd_display($fd, $state)"
Maps to \f(CW\*(C`void lcdDisplay(int fd, int state)\*(C'\fR
.PP
Turns the \s-1LCD\s0 display on and off.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.PP
.Vb 1
\&    $state
.Ve
.PP
Mandatory: \f(CW0\fR to turn the display off, and \f(CW1\fR for on.
.ie n .SS "lcd_cursor($fd, $state)"
.el .SS "lcd_cursor($fd, \f(CW$state\fP)"
.IX Subsection "lcd_cursor($fd, $state)"
Maps to \f(CW\*(C`void lcdCursor(int fd, int state)\*(C'\fR
.PP
Turns the \s-1LCD\s0 cursor on and off.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.=head2 lcd_clear($fd)
.PP
.Vb 1
\&    $state
.Ve
.PP
Mandatory: \f(CW0\fR to turn the cursor off, \f(CW1\fR for on.
.ie n .SS "lcd_cursor_blink($fd, $state)"
.el .SS "lcd_cursor_blink($fd, \f(CW$state\fP)"
.IX Subsection "lcd_cursor_blink($fd, $state)"
Maps to \f(CW\*(C`void lcdCursorBlink(int fd, int state)\*(C'\fR
.PP
Allows you to enable/disable a blinking cursor.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.=head2 lcd_clear($fd)
.PP
.Vb 1
\&    $state
.Ve
.PP
Mandatory: \f(CW0\fR to stop blinking, \f(CW1\fR to enable.
.ie n .SS "lcd_send_cmd($fd, $command)"
.el .SS "lcd_send_cmd($fd, \f(CW$command\fP)"
.IX Subsection "lcd_send_cmd($fd, $command)"
Maps to \f(CW\*(C`void lcdSendCommand(int fd, char command)\*(C'\fR
.PP
Sends any arbitrary command to the \s-1LCD.\s0
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.=head2 lcd_clear($fd)
.PP
.Vb 1
\&    $command
.Ve
.PP
Mandatory: A command to submit to the \s-1LCD.\s0
.ie n .SS "lcd_position($fd, $x, $y)"
.el .SS "lcd_position($fd, \f(CW$x\fP, \f(CW$y\fP)"
.IX Subsection "lcd_position($fd, $x, $y)"
Maps to \f(CW\*(C`void lcdPosition(int fd, int x, int y)\*(C'\fR
.PP
Moves the cursor to the specified position on the \s-1LCD\s0 display.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.PP
.Vb 1
\&    $x
.Ve
.PP
Mandatory: Column position. \f(CW0\fR is the left-most edge.
.PP
.Vb 1
\&    $y
.Ve
.PP
Mandatory: Row position. \f(CW0\fR is the top row.
.ie n .SS "lcd_char_def($fd, $index, $data)"
.el .SS "lcd_char_def($fd, \f(CW$index\fP, \f(CW$data\fP)"
.IX Subsection "lcd_char_def($fd, $index, $data)"
Maps to \f(CW\*(C`void lcdCharDef(int fd, unsigned char data [8])\*(C'\fR
.PP
This allows you to re-define one of the 8 user-definable characters in the
display. The data array is 8 bytes which represent the character from the
top-line to the bottom line. Note that the characters are actually 5×8, so
only the lower 5 bits are used. The index is from 0 to 7 and you can
subsequently print the character defined using the \fIlcdPutchar()\fR call.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.PP
.Vb 1
\&    $index
.Ve
.PP
Mandatory: Index of the display character. Values are \f(CW\*(C`0\-7\*(C'\fR.
.PP
.Vb 1
\&    $data
.Ve
.PP
Mandatory: See above description.
.ie n .SS "lcd_put_char($fd, $char)"
.el .SS "lcd_put_char($fd, \f(CW$char\fP)"
.IX Subsection "lcd_put_char($fd, $char)"
Maps to \f(CW\*(C`void lcdPutChar(int fd, unsigned char data)\*(C'\fR
.PP
Writes a single \s-1ASCII\s0 character to the \s-1LCD\s0 display, at the current cursor
position.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.PP
.Vb 1
\&    $char
.Ve
.PP
Mandatory: A single \s-1ASCII\s0 character.
.ie n .SS "lcd_puts($fd, $string)"
.el .SS "lcd_puts($fd, \f(CW$string\fP)"
.IX Subsection "lcd_puts($fd, $string)"
Maps to \f(CW\*(C`void lcdPuts(int fd, char *string)\*(C'\fR
.PP
Writes a string to the \s-1LCD\s0 display, at the current cursor position.
.PP
Parameters:
.PP
.Vb 1
\&    $fd
.Ve
.PP
Mandatory: The file descriptor integer returned by \f(CW\*(C`lcd_init()\*(C'\fR.
.PP
.Vb 1
\&    $string
.Ve
.PP
Mandatory: A string to display.
.SH "AUTHOR"
.IX Header "AUTHOR"
Steve Bertrand, <steveb@cpan.org>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2016 by Steve Bertrand
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.18.2 or,
at your option, any later version of Perl 5 you may have available.
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 527:" 4
.IX Item "Around line 527:"
Non-ASCII character seen before =encoding in '5×8,'. Assuming \s-1UTF\-8\s0
